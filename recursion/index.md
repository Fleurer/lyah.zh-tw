---
layout: page
title: 遞迴
prev:
    url: syntax-in-functions
    title: Function 中的語法
---

## <a name="hello-recursion">遞迴，你好！</a>

<img src="img/recursion.png" alt="SOVIET RUSSIA" style="float:left" />
在先前的章節中我們簡略地提到過遞迴。在這一章，我們將會更仔細地看看遞迴、為什麼它對 Haskell 來說是很重要的、以及我們如何藉由遞迴思考，來針對問題想出非常簡潔且優雅的解答。

如果你還是不知道遞迴是什麼，就讀讀這一句。哈哈！開個玩笑而已！遞迴實際上是一種定義函數的方式，其中這個函數被應用在它自己的定義裡頭。數學中的定義往往以遞迴的形式給定。舉例來說，費波那契數列（fibonacci sequence）就被遞迴地定義。首先，我們非遞迴地定義前兩個費波那契數。我們說 <i>F(0) = 0</i> 且 <i>F(1) = 1</i>，代表第 0 個與第 1 個費波那契數分別是 0 和 1。然後我們說，對於任何其他的自然數，此費波那契數為前兩個費波那契數的總和。所以 <i>F(n) = F(n-1) + F(n-2)</i>。如此一來，<i>F(3)</i> 為 <i>F(2) + F(1)</i>，即是 <i>(F(1) + F(0)) + F(1)</i>。因為我們現在拆解到只剩非遞迴定義的費波那契數，所以我們可以有把握地說：<i>F(3)</i> 為 2。在遞迴函數中有一兩個非遞迴定義的元素（像是這裡的 <i>F(0)</i> 與 <i>F(1)</i>）也被稱為*邊界條件*，如果你想要你的遞迴 function 終止，這是很重要的。假使我們沒有非遞迴地定義 <i>F(0)</i> 與 <i>F(1)</i>，對於任何數字你都不會得到一個解答，因為你會到達 0，然後進入負數。突然間，你已經算到 <i>F(-2000)</i> 為 <i>F(-2001) + F(-2002)</i>，卻仍然看不到盡頭。

遞迴對 Haskell 是重要的，因為不若命令式語言，你在 Haskell 中是藉由宣告「某個東西<i>是</i>什麼」而不是宣告「你<i>如何</i>得到它」來進行計算。這就是為什麼在 Haskell 中沒有 while 迴圈（loop）或是 for 迴圈，而我們很多時候都必須要使用遞迴來宣告「某個東西是什麼」。

## <a name="maximum-awesome">Maximum 真棒</a>

## <a name="a-few-more-recursive-functions">再來一點遞迴 function</a>

## <a name="quick-sort">快速，排序！</a>

## <a name="thinking-recursively">遞迴地思考</a>

